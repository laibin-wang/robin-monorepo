import type { EChartsOption, ResizeOpts } from 'echarts/types/dist/shared'

import {
	inject,
	onMounted,
	onUnmounted,
	provide,
	reactive,
	ref,
	shallowRef,
	useTemplateRef,
	type InjectionKey,
} from 'vue'

import type { ChartContext, UpdateOptions, UseChartOptions, UseChartReturn } from '../types'

import { Chart } from '../core/Chart'
import { ChartManager } from '../core/ChartManager'
import { createModuleCollector, ModuleCollectorKey } from './useModuleCollector'
import { generateId } from '../utils/chartHelpers'

export const ChartKey: InjectionKey<Partial<ChartContext>> = Symbol('ChartContext')

export function useChart(options: UseChartOptions = {}): UseChartReturn {
	const {
		config = {},
		initialModules = [],
		id = generateId('ins'),
		onReady,
		onError
	} = options

	const containerRef = useTemplateRef<HTMLElement | null>('chartBrickRef')
	const chart = shallowRef<Chart | null>(null)
	const isReady = ref(false)
	const isLoading = ref(false)
	const error = ref<Error | null>(null)
	const optionState = reactive<EChartsOption>({})

	const manager = ChartManager.getInstance()
	const { collector } = createModuleCollector()
	provide(ModuleCollectorKey, collector)
	provide(ChartKey, {
		chart: chart,
		setOptionByOne: (id, type, option) => {
			if(!option) return
			// 判断type 是否在 optionState 中，如果在，则直接赋值，如果不在，则新增一个属性
			if (type in optionState) {
				// 判断是否有 _rcb_id 属性，如果有，则说明是同一个组件的属性，则直接赋值，如果没有，则新增一个属性
				const inx = (optionState[type] as any[]).findIndex(item => item._rcb_id === id)
				if (inx > -1) {
					(optionState[type] as any[])[inx] = {...option, _rcb_id: id }
				} else {
					(optionState[type] as any[]).push({...option, _rcb_id: id })
				}
			} else {
				optionState[type] = [{...option, _rcb_id: id }]
			}
			console.log('setOptionByOne', id, type, optionState)
		},
		setCartesianGrid: opt => {
			optionState.yAxis = opt.yAxis
			optionState.grid = opt.grid
			optionState.xAxis = opt.xAxis
			console.log('setCartesianGrid', optionState)
		}
	})


	onMounted(async () => {
		if (!containerRef.value) {
			error.value = new Error('Container element not found')
			onError?.(error.value)
			return
		}

		try {
			isLoading.value = true
			const instance = new Chart(containerRef.value, config)
			const declaredModules = collector.getAll()
			const allModules = [...new Set([...initialModules, ...declaredModules])]
			console.log('allModules', allModules)
			instance.require(...allModules)

			await instance.init()

			chart.value = instance
			manager.register(id, instance)
			isReady.value = true
			isLoading.value = false

			onReady?.(instance)
			instance.setOption(optionState as EChartsOption, {})
			console.log('optionState-getOption', instance.getOption())
		} catch (err) {
			isLoading.value = false
			error.value = err instanceof Error ? err : new Error(String(err))
			onError?.(error.value)
		}
	})

	onUnmounted(() => {
		manager.dispose(id)
		chart.value?.dispose()
		isReady.value = false
	})

	return {
		chartRef: containerRef,
		chart,
		isReady,
		isLoading,
		error,
		setOption: (opt: EChartsOption, opts: UpdateOptions = {}) => chart.value?.setOption(opt, opts),
		resize: (opts: ResizeOpts) => chart.value?.resize(opts),
		dispatchAction: payload => chart.value?.dispatchAction(payload),
		on: (event: string, handler: Function) => chart.value?.on(event, handler),
		off: (event: string, handler: Function) => chart.value?.off(event, handler),
		showLoading: opts => chart.value?.showLoading(opts),
		hideLoading: () => chart.value?.hideLoading(),
		clear: () => chart.value?.clear(),
		dispose: () => chart.value?.dispose(),
		getOption: () => chart.value?.getOption(),
	}
}
export function useChartContext(): ChartContext {
	const ctx = inject<ChartContext>(ChartKey)
	if (!ctx) {
		throw new Error('useChartContext must be used inside a Chart component')
	}
	return ctx
}
